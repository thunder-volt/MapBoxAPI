{"ast":null,"code":"import * as types from '../constants/action_types';\nimport utils from '../utils';\nvar request = new XMLHttpRequest();\n\nfunction originPoint(coordinates) {\n  return function (dispatch) {\n    var origin = utils.createPoint(coordinates, {\n      id: 'origin',\n      'marker-symbol': 'A'\n    });\n    dispatch({\n      type: types.ORIGIN,\n      origin: origin\n    });\n    dispatch(eventEmit('origin', {\n      feature: origin\n    }));\n  };\n}\n\nfunction destinationPoint(coordinates) {\n  return function (dispatch) {\n    var destination = utils.createPoint(coordinates, {\n      id: 'destination',\n      'marker-symbol': 'B'\n    });\n    dispatch({\n      type: types.DESTINATION,\n      destination: destination\n    });\n    dispatch(eventEmit('destination', {\n      feature: destination\n    }));\n  };\n}\n\nfunction setDirections(directions) {\n  return function (dispatch) {\n    dispatch({\n      type: types.DIRECTIONS,\n      directions: directions\n    });\n    dispatch(eventEmit('route', {\n      route: directions\n    }));\n  };\n}\n\nfunction updateWaypoints(waypoints) {\n  return {\n    type: types.WAYPOINTS,\n    waypoints: waypoints\n  };\n}\n\nfunction setHoverMarker(feature) {\n  return {\n    type: types.HOVER_MARKER,\n    hoverMarker: feature\n  };\n}\n\nfunction fetchDirections() {\n  return function (dispatch, getState) {\n    var _getState = getState(),\n        api = _getState.api,\n        accessToken = _getState.accessToken,\n        routeIndex = _getState.routeIndex,\n        profile = _getState.profile,\n        alternatives = _getState.alternatives,\n        congestion = _getState.congestion,\n        destination = _getState.destination,\n        language = _getState.language,\n        exclude = _getState.exclude; // if there is no destination set, do not make request because it will fail\n\n\n    if (!(destination && destination.geometry)) return;\n    var query = buildDirectionsQuery(getState); // Request params\n\n    var options = [];\n    options.push('geometries=polyline');\n    if (alternatives) options.push('alternatives=true');\n    if (congestion) options.push('annotations=congestion');\n    options.push('steps=true');\n    options.push('overview=full');\n    if (language) options.push('language=' + language);\n    if (exclude) options.push('exclude=' + exclude);\n    if (accessToken) options.push('access_token=' + accessToken);\n    request.abort();\n    request.open('GET', \"\".concat(api).concat(profile, \"/\").concat(query, \".json?\").concat(options.join('&')), true);\n\n    request.onload = function () {\n      if (request.status >= 200 && request.status < 400) {\n        var data = JSON.parse(request.responseText);\n\n        if (data.error) {\n          dispatch(setDirections([]));\n          return dispatch(setError(data.error));\n        }\n\n        dispatch(setError(null));\n        if (!data.routes[routeIndex]) dispatch(setRouteIndex(0));\n        dispatch(setDirections(data.routes)); // Revise origin / destination points\n\n        dispatch(originPoint(data.waypoints[0].location));\n        dispatch(destinationPoint(data.waypoints[data.waypoints.length - 1].location));\n      } else {\n        dispatch(setDirections([]));\n        return dispatch(setError(JSON.parse(request.responseText).message));\n      }\n    };\n\n    request.onerror = function () {\n      dispatch(setDirections([]));\n      return dispatch(setError(JSON.parse(request.responseText).message));\n    };\n\n    request.send();\n  };\n}\n/*\n * Build query used to fetch directions\n *\n * @param {Function} state\n */\n\n\nfunction buildDirectionsQuery(state) {\n  var _state = state(),\n      origin = _state.origin,\n      destination = _state.destination,\n      waypoints = _state.waypoints;\n\n  var query = [];\n  query.push(origin.geometry.coordinates.join(','));\n  query.push(';'); // Add any waypoints.\n\n  if (waypoints.length) {\n    waypoints.forEach(function (waypoint) {\n      query.push(waypoint.geometry.coordinates.join(','));\n      query.push(';');\n    });\n  }\n\n  query.push(destination.geometry.coordinates.join(','));\n  return encodeURIComponent(query.join(''));\n}\n\nfunction normalizeWaypoint(waypoint) {\n  var properties = {\n    id: 'waypoint'\n  };\n  return Object.assign(waypoint, {\n    properties: waypoint.properties ? Object.assign(waypoint.properties, properties) : properties\n  });\n}\n\nfunction setError(error) {\n  return function (dispatch) {\n    dispatch({\n      type: 'ERROR',\n      error: error\n    });\n    if (error) dispatch(eventEmit('error', {\n      error: error\n    }));\n  };\n}\n\nexport function queryOrigin(query) {\n  return {\n    type: types.ORIGIN_QUERY,\n    query: query\n  };\n}\nexport function queryDestination(query) {\n  return {\n    type: types.DESTINATION_QUERY,\n    query: query\n  };\n}\nexport function queryOriginCoordinates(coords) {\n  return {\n    type: types.ORIGIN_FROM_COORDINATES,\n    coordinates: coords\n  };\n}\nexport function queryDestinationCoordinates(coords) {\n  return {\n    type: types.DESTINATION_FROM_COORDINATES,\n    coordinates: coords\n  };\n}\nexport function clearOrigin() {\n  return function (dispatch) {\n    dispatch({\n      type: types.ORIGIN_CLEAR\n    });\n    dispatch(eventEmit('clear', {\n      type: 'origin'\n    }));\n    dispatch(setError(null));\n  };\n}\nexport function clearDestination() {\n  return function (dispatch) {\n    dispatch({\n      type: types.DESTINATION_CLEAR\n    });\n    dispatch(eventEmit('clear', {\n      type: 'destination'\n    }));\n    dispatch(setError(null));\n  };\n}\nexport function setOptions(options) {\n  return {\n    type: types.SET_OPTIONS,\n    options: options\n  };\n}\nexport function hoverMarker(coordinates) {\n  return function (dispatch) {\n    var feature = coordinates ? utils.createPoint(coordinates, {\n      id: 'hover'\n    }) : {};\n    dispatch(setHoverMarker(feature));\n  };\n}\nexport function setRouteIndex(routeIndex) {\n  return {\n    type: types.ROUTE_INDEX,\n    routeIndex: routeIndex\n  };\n}\nexport function createOrigin(coordinates) {\n  return function (dispatch, getState) {\n    var _getState2 = getState(),\n        destination = _getState2.destination;\n\n    dispatch(originPoint(coordinates));\n    if (destination.geometry) dispatch(fetchDirections());\n  };\n}\nexport function createDestination(coordinates) {\n  return function (dispatch, getState) {\n    var _getState3 = getState(),\n        origin = _getState3.origin;\n\n    dispatch(destinationPoint(coordinates));\n    if (origin.geometry) dispatch(fetchDirections());\n  };\n}\nexport function setProfile(profile) {\n  return function (dispatch, getState) {\n    var _getState4 = getState(),\n        origin = _getState4.origin,\n        destination = _getState4.destination;\n\n    dispatch({\n      type: types.DIRECTIONS_PROFILE,\n      profile: profile\n    });\n    dispatch(eventEmit('profile', {\n      profile: profile\n    }));\n    if (origin.geometry && destination.geometry) dispatch(fetchDirections());\n  };\n}\nexport function reverse() {\n  return function (dispatch, getState) {\n    var state = getState();\n    if (state.destination.geometry) dispatch(originPoint(state.destination.geometry.coordinates));\n    if (state.origin.geometry) dispatch(destinationPoint(state.origin.geometry.coordinates));\n    if (state.origin.geometry && state.destination.geometry) dispatch(fetchDirections());\n    var suggestions = document.getElementsByClassName('suggestions');\n\n    for (var i = 0; i < suggestions.length; i++) {\n      suggestions[i].style.visibility = 'hidden';\n    }\n\n    ;\n  };\n}\n/*\n * Set origin from coordinates\n *\n * @param {Array<number>} coordinates [lng, lat] array.\n */\n\nexport function setOriginFromCoordinates(coords) {\n  return function (dispatch) {\n    if (!utils.validCoords(coords)) coords = [utils.wrap(coords[0]), utils.wrap(coords[1])];\n    if (isNaN(coords[0]) && isNaN(coords[1])) return dispatch(setError(new Error('Coordinates are not valid')));\n    dispatch(queryOriginCoordinates(coords));\n    dispatch(createOrigin(coords));\n  };\n}\n/*\n * Set destination from coordinates\n *\n * @param {Array<number>} coords [lng, lat] array.\n */\n\nexport function setDestinationFromCoordinates(coords) {\n  return function (dispatch) {\n    if (!utils.validCoords(coords)) coords = [utils.wrap(coords[0]), utils.wrap(coords[1])];\n    if (isNaN(coords[0]) && isNaN(coords[1])) return dispatch(setError(new Error('Coordinates are not valid')));\n    dispatch(createDestination(coords));\n    dispatch(queryDestinationCoordinates(coords));\n  };\n}\nexport function addWaypoint(index, waypoint) {\n  return function (dispatch, getState) {\n    var _getState5 = getState(),\n        destination = _getState5.destination,\n        waypoints = _getState5.waypoints;\n\n    waypoints.splice(index, 0, normalizeWaypoint(waypoint));\n    dispatch(updateWaypoints(waypoints));\n    if (destination.geometry) dispatch(fetchDirections());\n  };\n}\nexport function setWaypoint(index, waypoint) {\n  return function (dispatch, getState) {\n    var _getState6 = getState(),\n        destination = _getState6.destination,\n        waypoints = _getState6.waypoints;\n\n    waypoints[index] = normalizeWaypoint(waypoint);\n    dispatch(updateWaypoints(waypoints));\n    if (destination.geometry) dispatch(fetchDirections());\n  };\n}\nexport function removeWaypoint(waypoint) {\n  return function (dispatch, getState) {\n    var _getState7 = getState(),\n        destination = _getState7.destination,\n        waypoints = _getState7.waypoints;\n\n    waypoints = waypoints.filter(function (way) {\n      return !utils.coordinateMatch(way, waypoint);\n    });\n    dispatch(updateWaypoints(waypoints));\n    if (destination.geometry) dispatch(fetchDirections());\n  };\n}\nexport function eventSubscribe(type, fn) {\n  return function (dispatch, getState) {\n    var _getState8 = getState(),\n        events = _getState8.events;\n\n    events[type] = events[type] || [];\n    events[type].push(fn);\n    return {\n      type: types.EVENTS,\n      events: events\n    };\n  };\n}\nexport function eventEmit(type, data) {\n  var _this = this;\n\n  return function (dispatch, getState) {\n    var _getState9 = getState(),\n        events = _getState9.events;\n\n    if (!events[type]) {\n      return {\n        type: types.EVENTS,\n        events: events\n      };\n    }\n\n    var listeners = events[type].slice();\n\n    for (var i = 0; i < listeners.length; i++) {\n      listeners[i].call(_this, data);\n    }\n  };\n}","map":null,"metadata":{},"sourceType":"module"}