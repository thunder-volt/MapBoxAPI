{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\ishu1\\\\OneDrive\\\\Documents\\\\MapBoxAPI_React\\\\mapbox\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\ishu1\\\\OneDrive\\\\Documents\\\\MapBoxAPI_React\\\\mapbox\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport { createStore, applyMiddleware, bindActionCreators } from 'redux';\nimport thunk from 'redux-thunk';\nimport { decode } from '@mapbox/polyline';\nimport utils from './utils';\nimport rootReducer from './reducers';\nvar storeWithMiddleware = applyMiddleware(thunk)(createStore);\nvar store = storeWithMiddleware(rootReducer); // State object management via redux\n\nimport * as actions from './actions';\nimport directionsStyle from './directions_style'; // Controls\n\nimport Inputs from './controls/inputs';\nimport Instructions from './controls/instructions';\n/**\n * The Directions control\n * @class MapboxDirections\n *\n * @param {Object} options\n * @param {Array} [options.styles] Override default layer properties of the [directions source](https://github.com/mapbox/mapbox-gl-directions/blob/master/src/directions_style.js). Documentation for each property are specified in the [Mapbox GL Style Reference](https://www.mapbox.com/mapbox-gl-style-spec/).\n * @param {String} [options.accessToken=null] Required unless `mapboxgl.accessToken` is set globally\n * @param {String} [options.api=\"https://api.mapbox.com/directions/v5/\"] Override default routing endpoint url\n * @param {Boolean} [options.interactive=true] Enable/Disable mouse or touch interactivity from the plugin\n * @param {String} [options.profile=\"mapbox/driving-traffic\"] Routing profile to use. Options: `mapbox/driving-traffic`, `mapbox/driving`, `mapbox/walking`, `mapbox/cycling`\n * @param {Boolean} [options.alternatives=false] Whether to enable alternatives.\n * @param {Boolean} [options.congestion=false] Whether to enable congestion along the route line.\n * @param {String} [options.unit=\"imperial\"] Measurement system to be used in navigation instructions. Options: `imperial`, `metric`\n * @param {Function} [options.compile=null] Provide a custom function for generating instruction, compatible with osrm-text-instructions.\n * @param {Object} [options.geocoder] Accepts an object containing the query parameters as [documented here](https://www.mapbox.com/api-documentation/#search-for-places).\n * @param {Object} [options.controls]\n * @param {Boolean} [options.controls.inputs=true] Hide or display the inputs control.\n * @param {Boolean} [options.controls.instructions=true] Hide or display the instructions control.\n * @param {Boolean} [options.controls.profileSwitcher=true] Hide or display the default profile switch with options for traffic, driving, walking and cycling.\n * @param {Number} [options.zoom=16] If no bbox exists from the geocoder result, the zoom you set here will be used in the flyTo.\n * @param {String} [options.language=\"en\"] The language of returned turn-by-turn text instructions. See supported languages : https://docs.mapbox.com/api/navigation/#instructions-languages\n * @param {String} [options.placeholderOrigin=\"Choose a starting place\"] If set, this text will appear as the placeholder attribute for the origin input element.\n * @param {String} [options.placeholderDestination=\"Choose destination\"] If set, this text will appear as the placeholder attribute for the destination input element.\n * @param {Boolean} [options.flyTo=true] If false, animating the map to a selected result is disabled.\n * @param {String} [options.exclude=null] Exclude certain road types from routing. The default is to not exclude anything. Search for `exclude` in `optional parameters`: https://docs.mapbox.com/api/navigation/#retrieve-directions\n * @param {number | PaddingOptions} [options.routePadding=80] Specify padding surrounding route. A single number of pixels or a [PaddingOptions](https://docs.mapbox.com/mapbox-gl-js/api/#paddingoptions) object.\n * @example\n * var MapboxDirections = require('../src/index');\n * var directions = new MapboxDirections({\n *   accessToken: 'YOUR-MAPBOX-ACCESS-TOKEN',\n *   unit: 'metric',\n *   profile: 'mapbox/cycling'\n * });\n * // add to your mapboxgl map\n * map.addControl(directions);\n *\n * @return {MapboxDirections} `this`\n */\n\nvar MapboxDirections = /*#__PURE__*/function () {\n  function MapboxDirections(options) {\n    _classCallCheck(this, MapboxDirections);\n\n    this.actions = bindActionCreators(actions, store.dispatch);\n    this.actions.setOptions(options || {});\n    this.options = options || {};\n    this.onDragDown = this._onDragDown.bind(this);\n    this.onDragMove = this._onDragMove.bind(this);\n    this.onDragUp = this._onDragUp.bind(this);\n    this.move = this._move.bind(this);\n    this.onClick = this._clickHandler().bind(this);\n  }\n\n  _createClass(MapboxDirections, [{\n    key: \"onAdd\",\n    value: function onAdd(map) {\n      var _this = this;\n\n      this._map = map;\n\n      var _store$getState = store.getState(),\n          controls = _store$getState.controls;\n\n      var el = this.container = document.createElement('div');\n      el.className = 'mapboxgl-ctrl-directions mapboxgl-ctrl'; // Add controls to the page\n\n      var inputEl = document.createElement('div');\n      inputEl.className = 'directions-control directions-control-inputs';\n      new Inputs(inputEl, store, this.actions, this._map);\n      var directionsEl = document.createElement('div');\n      directionsEl.className = 'directions-control directions-control-instructions';\n      new Instructions(directionsEl, store, {\n        hoverMarker: this.actions.hoverMarker,\n        setRouteIndex: this.actions.setRouteIndex\n      }, this._map);\n      if (controls.inputs) el.appendChild(inputEl);\n      if (controls.instructions) el.appendChild(directionsEl);\n      this.subscribedActions();\n      if (this._map.loaded()) this.mapState();else this._map.on('load', function () {\n        return _this.mapState();\n      });\n      return el;\n    }\n    /**\n     * Removes the control from the map it has been added to. This is called by `map.removeControl`,\n     * which is the recommended method to remove controls.\n     *\n     * @returns {Control} `this`\n     */\n\n  }, {\n    key: \"onRemove\",\n    value: function onRemove(map) {\n      this.container.parentNode.removeChild(this.container);\n      this.removeRoutes();\n      map.off('mousedown', this.onDragDown);\n      map.off('mousemove', this.move);\n      map.off('touchstart', this.onDragDown);\n      map.off('touchstart', this.move);\n      map.off('click', this.onClick);\n\n      if (this.storeUnsubscribe) {\n        this.storeUnsubscribe();\n        delete this.storeUnsubscribe;\n      }\n\n      directionsStyle.forEach(function (layer) {\n        if (map.getLayer(layer.id)) map.removeLayer(layer.id);\n      });\n      if (map.getSource('directions')) map.removeSource('directions');\n      this._map = null;\n      return this;\n    }\n  }, {\n    key: \"mapState\",\n    value: function mapState() {\n      var _this2 = this;\n\n      var _store$getState2 = store.getState(),\n          profile = _store$getState2.profile,\n          alternatives = _store$getState2.alternatives,\n          congestion = _store$getState2.congestion,\n          styles = _store$getState2.styles,\n          interactive = _store$getState2.interactive,\n          compile = _store$getState2.compile; // Emit any default or option set config\n\n\n      this.actions.eventEmit('profile', {\n        profile: profile\n      });\n      var geojson = {\n        type: 'geojson',\n        data: {\n          type: 'FeatureCollection',\n          features: []\n        }\n      }; // Add and set data theme layer/style\n\n      this._map.addSource('directions', geojson); // Add direction specific styles to the map\n\n\n      if (styles && styles.length) styles.forEach(function (style) {\n        return _this2._map.addLayer(style);\n      });\n      directionsStyle.forEach(function (style) {\n        // only add the default style layer if a custom layer wasn't provided\n        if (!_this2._map.getLayer(style.id)) _this2._map.addLayer(style);\n      });\n\n      if (interactive) {\n        this._map.on('mousedown', this.onDragDown);\n\n        this._map.on('mousemove', this.move);\n\n        this._map.on('click', this.onClick);\n\n        this._map.on('touchstart', this.move);\n\n        this._map.on('touchstart', this.onDragDown);\n      }\n    }\n  }, {\n    key: \"subscribedActions\",\n    value: function subscribedActions() {\n      var _this3 = this;\n\n      this.storeUnsubscribe = store.subscribe(function () {\n        var _store$getState3 = store.getState(),\n            origin = _store$getState3.origin,\n            destination = _store$getState3.destination,\n            hoverMarker = _store$getState3.hoverMarker,\n            directions = _store$getState3.directions,\n            routeIndex = _store$getState3.routeIndex;\n\n        var geojson = {\n          type: 'FeatureCollection',\n          features: [origin, destination, hoverMarker].filter(function (d) {\n            return d.geometry;\n          })\n        };\n\n        if (directions.length) {\n          directions.forEach(function (feature, index) {\n            var features = [];\n            var decoded = decode(feature.geometry, 5).map(function (c) {\n              return c.reverse();\n            });\n            decoded.forEach(function (c, i) {\n              var previous = features[features.length - 1];\n              var congestion = feature.legs[0].annotation && feature.legs[0].annotation.congestion && feature.legs[0].annotation.congestion[i - 1];\n\n              if (previous && (!congestion || previous.properties.congestion === congestion)) {\n                previous.geometry.coordinates.push(c);\n              } else {\n                var segment = {\n                  geometry: {\n                    type: 'LineString',\n                    coordinates: []\n                  },\n                  properties: {\n                    'route-index': index,\n                    route: index === routeIndex ? 'selected' : 'alternate'\n                  }\n                }; // New segment starts with previous segment's last coordinate.\n\n                if (previous) segment.geometry.coordinates.push(previous.geometry.coordinates[previous.geometry.coordinates.length - 1]);\n                segment.geometry.coordinates.push(c);\n\n                if (congestion) {\n                  segment.properties.congestion = feature.legs[0].annotation.congestion[i - 1];\n                }\n\n                features.push(segment);\n              }\n            });\n            geojson.features = geojson.features.concat(features);\n\n            if (index === routeIndex) {\n              // Collect any possible waypoints from steps\n              feature.legs[0].steps.forEach(function (d) {\n                if (d.maneuver.type === 'waypoint') {\n                  geojson.features.push({\n                    type: 'Feature',\n                    geometry: d.maneuver.location,\n                    properties: {\n                      id: 'waypoint'\n                    }\n                  });\n                }\n              });\n            }\n          });\n        }\n\n        if (_this3._map.style && _this3._map.getSource('directions')) {\n          _this3._map.getSource('directions').setData(geojson);\n        }\n      });\n    }\n  }, {\n    key: \"_clickHandler\",\n    value: function _clickHandler() {\n      var timer = null;\n      var delay = 250;\n      return function (event) {\n        if (!timer) {\n          var singleClickHandler = this._onSingleClick.bind(this);\n\n          timer = setTimeout(function () {\n            singleClickHandler(event);\n            timer = null;\n          }, delay);\n        } else {\n          clearTimeout(timer);\n          timer = null;\n\n          this._map.zoomIn();\n        }\n      };\n    }\n  }, {\n    key: \"_onSingleClick\",\n    value: function _onSingleClick(e) {\n      var _this4 = this;\n\n      var _store$getState4 = store.getState(),\n          origin = _store$getState4.origin;\n\n      var coords = [e.lngLat.lng, e.lngLat.lat];\n\n      if (!origin.geometry) {\n        this.actions.setOriginFromCoordinates(coords);\n      } else {\n        var features = this._map.queryRenderedFeatures(e.point, {\n          layers: ['directions-origin-point', 'directions-destination-point', 'directions-waypoint-point', 'directions-route-line-alt']\n        });\n\n        if (features.length) {\n          // Remove any waypoints\n          features.forEach(function (f) {\n            if (f.layer.id === 'directions-waypoint-point') {\n              _this4.actions.removeWaypoint(f);\n            }\n          });\n\n          if (features[0].properties.route === 'alternate') {\n            var index = features[0].properties['route-index'];\n            this.actions.setRouteIndex(index);\n          }\n        } else {\n          this.actions.setDestinationFromCoordinates(coords);\n\n          this._map.flyTo({\n            center: coords\n          });\n        }\n      }\n    }\n  }, {\n    key: \"_move\",\n    value: function _move(e) {\n      var _this5 = this;\n\n      var _store$getState5 = store.getState(),\n          hoverMarker = _store$getState5.hoverMarker;\n\n      var features = this._map.queryRenderedFeatures(e.point, {\n        layers: ['directions-route-line-alt', 'directions-route-line', 'directions-origin-point', 'directions-destination-point', 'directions-hover-point']\n      });\n\n      this._map.getCanvas().style.cursor = features.length ? 'pointer' : '';\n\n      if (features.length) {\n        this.isCursorOverPoint = features[0];\n\n        this._map.dragPan.disable(); // Add a possible waypoint marker when hovering over the active route line\n\n\n        features.forEach(function (feature) {\n          if (feature.layer.id === 'directions-route-line') {\n            _this5.actions.hoverMarker([e.lngLat.lng, e.lngLat.lat]);\n          } else if (hoverMarker.geometry) {\n            _this5.actions.hoverMarker(null);\n          }\n        });\n      } else if (this.isCursorOverPoint) {\n        this.isCursorOverPoint = false;\n\n        this._map.dragPan.enable();\n      }\n    }\n  }, {\n    key: \"_onDragDown\",\n    value: function _onDragDown() {\n      if (!this.isCursorOverPoint) return;\n      this.isDragging = this.isCursorOverPoint;\n      this._map.getCanvas().style.cursor = 'grab';\n\n      this._map.on('mousemove', this.onDragMove);\n\n      this._map.on('mouseup', this.onDragUp);\n\n      this._map.on('touchmove', this.onDragMove);\n\n      this._map.on('touchend', this.onDragUp);\n    }\n  }, {\n    key: \"_onDragMove\",\n    value: function _onDragMove(e) {\n      if (!this.isDragging) return;\n      var coords = [e.lngLat.lng, e.lngLat.lat];\n\n      switch (this.isDragging.layer.id) {\n        case 'directions-origin-point':\n          this.actions.createOrigin(coords);\n          break;\n\n        case 'directions-destination-point':\n          this.actions.createDestination(coords);\n          break;\n\n        case 'directions-hover-point':\n          this.actions.hoverMarker(coords);\n          break;\n      }\n    }\n  }, {\n    key: \"_onDragUp\",\n    value: function _onDragUp() {\n      if (!this.isDragging) return;\n\n      var _store$getState6 = store.getState(),\n          hoverMarker = _store$getState6.hoverMarker,\n          origin = _store$getState6.origin,\n          destination = _store$getState6.destination;\n\n      switch (this.isDragging.layer.id) {\n        case 'directions-origin-point':\n          this.actions.setOriginFromCoordinates(origin.geometry.coordinates);\n          break;\n\n        case 'directions-destination-point':\n          this.actions.setDestinationFromCoordinates(destination.geometry.coordinates);\n          break;\n\n        case 'directions-hover-point':\n          // Add waypoint if a sufficent amount of dragging has occurred.\n          if (hoverMarker.geometry && !utils.coordinateMatch(this.isDragging, hoverMarker)) {\n            this.actions.addWaypoint(0, hoverMarker);\n          }\n\n          break;\n      }\n\n      this.isDragging = false;\n      this._map.getCanvas().style.cursor = '';\n\n      this._map.off('touchmove', this.onDragMove);\n\n      this._map.off('touchend', this.onDragUp);\n\n      this._map.off('mousemove', this.onDragMove);\n\n      this._map.off('mouseup', this.onDragUp);\n    } // API Methods\n    // ============================\n\n    /**\n     * Turn on or off interactivity\n     * @param {Boolean} state sets interactivity based on a state of `true` or `false`.\n     * @returns {MapboxDirections} this\n     */\n\n  }, {\n    key: \"interactive\",\n    value: function interactive(state) {\n      if (state) {\n        this._map.on('touchstart', this.move);\n\n        this._map.on('touchstart', this.onDragDown);\n\n        this._map.on('mousedown', this.onDragDown);\n\n        this._map.on('mousemove', this.move);\n\n        this._map.on('click', this.onClick);\n      } else {\n        this._map.off('touchstart', this.move);\n\n        this._map.off('touchstart', this.onDragDown);\n\n        this._map.off('mousedown', this.onDragDown);\n\n        this._map.off('mousemove', this.move);\n\n        this._map.off('click', this.onClick);\n      }\n\n      return this;\n    }\n    /**\n     * Returns the origin of the current route.\n     * @returns {Object} origin\n     */\n\n  }, {\n    key: \"getOrigin\",\n    value: function getOrigin() {\n      return store.getState().origin;\n    }\n    /**\n     * Sets origin. _Note:_ calling this method requires the [map load event](https://www.mapbox.com/mapbox-gl-js/api/#Map.load)\n     * to have run.\n     * @param {Array<number>|String} query An array of coordinates [lng, lat] or location name as a string.\n     * @returns {MapboxDirections} this\n     */\n\n  }, {\n    key: \"setOrigin\",\n    value: function setOrigin(query) {\n      if (typeof query === 'string') {\n        this.actions.queryOrigin(query);\n      } else {\n        this.actions.setOriginFromCoordinates(query);\n      }\n\n      return this;\n    }\n    /**\n     * Returns the destination of the current route.\n     * @returns {Object} destination\n     */\n\n  }, {\n    key: \"getDestination\",\n    value: function getDestination() {\n      return store.getState().destination;\n    }\n    /**\n     * Sets destination. _Note:_ calling this method requires the [map load event](https://www.mapbox.com/mapbox-gl-js/api/#Map.load)\n     * to have run.\n     * @param {Array<number>|String} query An array of coordinates [lng, lat] or location name as a string.\n     * @returns {MapboxDirections} this\n     */\n\n  }, {\n    key: \"setDestination\",\n    value: function setDestination(query) {\n      if (typeof query === 'string') {\n        this.actions.queryDestination(query);\n      } else {\n        this.actions.setDestinationFromCoordinates(query);\n      }\n\n      return this;\n    }\n    /**\n     * Swap the origin and destination.\n     * @returns {MapboxDirections} this\n     */\n\n  }, {\n    key: \"reverse\",\n    value: function reverse() {\n      this.actions.reverse();\n      return this;\n    }\n    /**\n     * Add a waypoint to the route. _Note:_ calling this method requires the\n     * [map load event](https://www.mapbox.com/mapbox-gl-js/api/#Map.load) to have run.\n     * @param {Number} index position waypoint should be placed in the waypoint array\n     * @param {Array<number>|Point} waypoint can be a GeoJSON Point Feature or [lng, lat] coordinates.\n     * @returns {MapboxDirections} this;\n     */\n\n  }, {\n    key: \"addWaypoint\",\n    value: function addWaypoint(index, waypoint) {\n      if (!waypoint.type) waypoint = utils.createPoint(waypoint, {\n        id: 'waypoint'\n      });\n      this.actions.addWaypoint(index, waypoint);\n      return this;\n    }\n    /**\n     * Change the waypoint at a given index in the route. _Note:_ calling this\n     * method requires the [map load event](https://www.mapbox.com/mapbox-gl-js/api/#Map.load)\n     * to have run.\n     * @param {Number} index indexed position of the waypoint to update\n     * @param {Array<number>|Point} waypoint can be a GeoJSON Point Feature or [lng, lat] coordinates.\n     * @returns {MapboxDirections} this;\n     */\n\n  }, {\n    key: \"setWaypoint\",\n    value: function setWaypoint(index, waypoint) {\n      if (!waypoint.type) waypoint = utils.createPoint(waypoint, {\n        id: 'waypoint'\n      });\n      this.actions.setWaypoint(index, waypoint);\n      return this;\n    }\n    /**\n     * Remove a waypoint from the route.\n     * @param {Number} index position in the waypoints array.\n     * @returns {MapboxDirections} this;\n     */\n\n  }, {\n    key: \"removeWaypoint\",\n    value: function removeWaypoint(index) {\n      var _store$getState7 = store.getState(),\n          waypoints = _store$getState7.waypoints;\n\n      this.actions.removeWaypoint(waypoints[index]);\n      return this;\n    }\n    /**\n     * Fetch all current waypoints in a route.\n     * @returns {Array} waypoints\n     */\n\n  }, {\n    key: \"getWaypoints\",\n    value: function getWaypoints() {\n      return store.getState().waypoints;\n    }\n    /**\n     * Removes all routes and waypoints from the map.\n     *\n     * @returns {MapboxDirections} this;\n     */\n\n  }, {\n    key: \"removeRoutes\",\n    value: function removeRoutes() {\n      this.actions.clearOrigin();\n      this.actions.clearDestination();\n      return this;\n    }\n    /**\n     * Subscribe to events that happen within the plugin.\n     * @param {String} type name of event. Available events and the data passed into their respective event objects are:\n     *\n     * - __clear__ `{ type: } Type is one of 'origin' or 'destination'`\n     * - __loading__ `{ type: } Type is one of 'origin' or 'destination'`\n     * - __profile__ `{ profile } Profile is one of 'driving', 'walking', or 'cycling'`\n     * - __origin__ `{ feature } Fired when origin is set`\n     * - __destination__ `{ feature } Fired when destination is set`\n     * - __route__ `{ route } Fired when a route is updated`\n     * - __error__ `{ error } Error as string`\n     * @param {Function} fn function that's called when the event is emitted.\n     * @returns {MapboxDirections} this;\n     */\n\n  }, {\n    key: \"on\",\n    value: function on(type, fn) {\n      this.actions.eventSubscribe(type, fn);\n      return this;\n    }\n  }]);\n\n  return MapboxDirections;\n}();\n\nexport { MapboxDirections as default };","map":null,"metadata":{},"sourceType":"module"}